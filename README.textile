M: Define literals:
R: "Hello world!"
=> 123
=> -23
=> 1.3
=> #("This", "is", "an", "array")
=> [ "This is a function" ]

M: Create an object:
R: {}

M: Store a local reference to an object:
R: object = {}
  
M: Assign keys in an object:
R: { attribute := "value" }

M: Assign keys outside an object:
R: object attribute := "value"

M: What does that last line do?
R: It sets the attribute value on object to "value"

M: What about in _{ attribute := "value" }_, what is the attribute being set on?
R: It is implicitly set on the _this_ object. _this_ refers to the current object in a given context. In the context above, _this_ is the newly created anonymous object.

M: What about in the first example, _object = {}_. What is _this_ here?
R: _this_ is a global scope object. Because the assignment is performed with _=_ rather than _:=_, the key is considered a local variable and saved in a _locals_ object on _this_.

M: What is the difference between assignment with _=_ and _:=_?
R: Assignments with _=_ are stored in the _locals_ object, while assignments with _:=_ are stored directly on _this_ in the current context, or on the object declared as the recipient of the assignment.

M: Can we formalize this definition a bit more?
R: We can try!

=> ({object} or implicit _this_) {key} := {value}
=> # ({object} or implicit _this_) {key} will return {value}. ({object} or implicit _this_) {keys} will include {key}

=> ({object} or implicit _this_) {key} = {value}
=> # ({object} or implicit _this_) {key} will return {value}. ({object} or implicit _this_) {keys} will not include {key}. ({object} or implicit _this_) {locals} will include {key}.

M: Why are you confusing me?!
R: This is done to help make a distinction between local keys and object keys. Message resolution for {key} will check in order (by default) {keys}, {locals} and then walk the {proto} list, looking for {key} in each of the prototypes, and then each of the prototypes' prototypes until the message is resolved, or the chain ends.
  
M: Retrieve values by their keys in an object:
R: { attribute := "value" } attribute
  
M: Define a function:
R: [ "hello" ]
  
M: Call a function:
R: [ "hello" ].
  
M: Define a function with arguments:
R: [ argument_1, argument_2 | argument_1 + argument_2 ]
  
M: Is _+_ a function?
R: Yes.

M: Above, is the response of argument_1 + having the message argument_2 sent to it?
R: No, _+_ is a binary function.

M: How do you know _+_ is a binary function?
R: Because _+_ is a message whose name contains no alphanumeric characters.

M: add_3_to_get_8! = { value := 5, + := [ argument | value + argument ] }
R: add_3_to_get_8! + 3
=> 8